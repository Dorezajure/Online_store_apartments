# 1. Роутер и маршруты

Определим основные страницы нашего SPA приложения:

-   Главная. Фильтр по поиску квартир. Отображение квартир карточками.
-   Объект. Страница с отдельным объектом.
-   Избранное. Страница с избранными объектами
-   Заявки. Страница с заявками

Продумаем адреса для страниц:

-   Главная "/"
-   Объект "/#/item/5"
-   Избранное "/#/favourites"
-   Заявки "/#/bids"

Напишем роутер который в зависимости от запросы будет показывать компонент с нужной "страницей".

На странице поределим блок `div#app` чтобы внутри него рендерить страницы с компонентами приложения.

# 2. Строим каркас верстки нашего приложения

Динамическая часть приложения будет распологаться по уентру страницы.
Верхняя панель с шапкой, логотип и подвал - статичны и будут присутствовать на любой странице, поэтому разместим их изначально в разметке.

В центральной части для динамического контента определим блок:

```
<div id="app">

</div>
```

# 3. Отрисовка главной страницы. Фильтр и листинг

Каждая страница будет состоять из отдельных компонентов. Так на главной у нас будет два компонента:

1. Фильтр для получения списка квартир;
2. Листинг для вывода списка квартир в виде карточек.

Можно подумать что легче объединить все это в один компонент, но в будущем в листинге может появитсья сортировка или пагинация. И тогда у одного компонента будет слишком много задач и ответственности. Поэтому стоит сделать разделение. Фильтр будет формаировать запрос - какие именно объекты (квартиры) необходимо получить с сервера, делать запрос и получать данные.

Дальнейшую отрисовку будет делать компонент листиинга. Он будет брать полученные данные, и отрисовывать их на странице.

Для передачи данных между компонентами - мы будем использовать объект state. state - это общепринятое название для такого объекта. Он будет хранить в себе состояние нашего приложения. Так как в приложении будет много компонентов - то все они неким образом должны знать что происходит на странице. state решает эту задачу. Все компоненты обращаются к state чтобы узнать какие квартиры есть для отображения, что находится в избранном, какая сортировка включена (если она есть), какая страница пагинации активна на текущий момент (если она тоже есть). Все компоненты сохраняют данные в state и берут данные из state. Таким образом реализуется общее хранилище данных.

Итак, займемся отрисовкой фильтра.

## Отрисовка фильтра

Создадим папку filter c тремя файлами view, model и controller.
В filterView опишем функцию рендера фильтра и вызовем ее в filterController.
В main.js вызовем filterController.

## Отрисовка листинга

Проделаем тоже самое и для листинга.

# Фильтр. Запуск фильтра и формирование строки запроса

Готово! Описываем функции в контроллере и в filterView
Для того чтобы получать значения из динамически отрисованных данных работаем черех `getElementsByClassName`

# Фильтр. Модель для Фильтра. Получение данных с сервера


# Фильтр. Запуск получения данных при старте и при выборе формы


# Фильтр. Запуск события сигнала для рендеринга листинга


# Листинг. Рендеринг карточек с объектами

1. Сначала делаем рендер листинга по клику и событию
2. После разбираемся с рендерингом при старте страницы

## Рендер при старте страницы

1) filterFormHandler должна возвращать промис, но внутри себя должна содержать Promise callback ASYNC функцию чтобы выполнять await
2) Сам filterCOntroller должен возвращать промис чтобы очередно выполняться в компоненте страницы, но чтобы внутри него была очередность его Promise callback функция также должна быть асинхронной
